#!/usr/bin/env bash
# ------------------------------------------------------------------------------
# Everest - Shared Library
# ------------------------------------------------------------------------------
# Common functions used across all Everest scripts.
# Source this file at the top of each script.
# ------------------------------------------------------------------------------

# Colors
# shellcheck disable=SC2034
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Defaults
CURL_RETRY=1
CURL_RETRY_DELAY=2
CURL_CONNECT_TIMEOUT=4
CURL_USER_AGENT="Everest/3.0.0 (https://github.com/E414CF6/Everest)"

# ------------------------------------------------------------------------------
# Logging
# ------------------------------------------------------------------------------

log_info() { echo -e "[$(date '+%H:%M:%S') ${GREEN}INFO${NC}] [${LOG_TAG:-everest}]: $1"; }
log_warn() { echo -e "[$(date '+%H:%M:%S') ${YELLOW}WARN${NC}] [${LOG_TAG:-everest}]: $1"; }
log_err() { echo -e "[$(date '+%H:%M:%S') ${RED}ERROR${NC}] [${LOG_TAG:-everest}]: $1" >&2; }

# ------------------------------------------------------------------------------
# Networking
# ------------------------------------------------------------------------------

_curl() {
    curl -fsSL \
        -H "User-Agent: ${CURL_USER_AGENT}" \
        --retry "${CURL_RETRY}" \
        --retry-delay "${CURL_RETRY_DELAY}" \
        --connect-timeout "${CURL_CONNECT_TIMEOUT}" \
        "$@"
}

curl_json() { _curl -H "Accept: application/json" "$1"; }
curl_html() { _curl "$1"; }
curl_download() { _curl -o "$2" "$1"; }

# ------------------------------------------------------------------------------
# Branch Resolution
# ------------------------------------------------------------------------------
# Resolves a branch config with parent inheritance (deep merge).
# Usage: resolve_branch <full_config_json> [branch_name]
# If branch_name is omitted, uses $EVEREST_BRANCH or defaultBranch from config.
# Returns: the resolved config object for that branch.
# ------------------------------------------------------------------------------

resolve_branch() {
    local config="$1"
    local branch="${2:-${EVEREST_BRANCH:-}}"

    jq --arg b "$branch" '
        def resolve($name):
            .branches[$name] as $br |
            if $br == null then
                error("Branch not found: " + $name)
            elif $br.parent then
                resolve($br.parent) * ($br | del(.parent))
            else
                $br
            end;
        if $b == "" then
            resolve(.defaultBranch)
        else
            resolve($b)
        end
    ' <<<"$config"
}

# ------------------------------------------------------------------------------
# Template Interpolation
# ------------------------------------------------------------------------------
# Replaces {key} placeholders in a template string with provided values.
# Usage: interpolate "https://{host}/job/{project}" host value project value ...
# ------------------------------------------------------------------------------

interpolate() {
    local result="$1"
    shift
    while [[ $# -ge 2 ]]; do
        result="${result//\{$1\}/$2}"
        shift 2
    done
    echo "$result"
}

# ------------------------------------------------------------------------------
# Cleanup Helper
# ------------------------------------------------------------------------------

cleanup_jobs() {
    local pids
    pids="$(jobs -pr 2>/dev/null || true)"
    if [[ -n "$pids" ]]; then
        # shellcheck disable=SC2086
        kill $pids 2>/dev/null || true
    fi
}

# ------------------------------------------------------------------------------
# Pick Latest File
# ------------------------------------------------------------------------------
# Finds the latest file matching a glob pattern in a directory (version-sorted).
# Usage: pick_latest <dir> <glob_pattern>
# Returns: full path to the latest file, or empty string.
# ------------------------------------------------------------------------------

pick_latest() {
    local dir="$1" pattern="$2"
    [[ -d "$dir" ]] || return 0
    find "$dir" -maxdepth 1 -type f -iname "$pattern" 2>/dev/null | sort -V | tail -n1
}

# ------------------------------------------------------------------------------
# Fallback Jar Recovery
# ------------------------------------------------------------------------------
# Tries to recover a jar from a fallback directory.
# Usage: try_fallback <name> <tag> <fallback_dir> <dest_dir>
# Returns: 0 if found and copied, 1 otherwise.
# ------------------------------------------------------------------------------

try_fallback() {
    local name="$1" tag="$2" fallback_dir="$3" dest_dir="$4"
    [[ -d "$fallback_dir" ]] || return 1
    local backup
    backup="$(find "$fallback_dir" -maxdepth 1 -type f -iname "*${name}*.jar" | head -n1 || true)"
    [[ -n "$backup" ]] || return 1
    cp -p "$backup" "$dest_dir/"
    log_info "Preserved: ${tag} ($(basename "$backup"))"
}

# ------------------------------------------------------------------------------
# Atomic Directory Swap
# ------------------------------------------------------------------------------

atomic_swap() {
    local src="$1" dest="$2"
    local backup="${dest}.bak.$$"

    mkdir -p "$(dirname "$dest")"

    if [[ -d "$dest" ]]; then
        mv "$dest" "$backup"
    fi

    if ! mv "$src" "$dest"; then
        log_err "Swap failed! Restoring backup..."
        [[ -d "$backup" ]] && mv "$backup" "$dest"
        return 1
    fi

    rm -rf "$backup" 2>/dev/null || true
}
